import{d as V}from"./DuAV58dt.js";import{u as B,aJ as W,a0 as p,aK as j,aL as q,L as w,aM as x,r as z,C as M,aA as I,Q,K as F,aN as G,aO as J,aP as U,c as Y,aQ as X,aR as R,Y as Z}from"./XKfp31o2.js";const $=Symbol.for("nuxt:client-only");function sa(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;A(a[0],a[1])&&a.unshift(e);let[u,o,n={}]=a,v=!1;const s=w(()=>J(u));if(typeof s.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=B();n.server??=!0,n.default??=k,n.getCachedData??=L,n.lazy??=!1,n.immediate??=!0,n.deep??=W.deep,n.dedupe??="cancel",n._functionName,t._asyncData[s.value];function h(){const l={cause:"initial",dedupe:n.dedupe};return t._asyncData[s.value]?._init||(l.cachedData=n.getCachedData(s.value,t,{cause:"initial"}),t._asyncData[s.value]=N(t,s.value,o,n,l.cachedData)),()=>t._asyncData[s.value].execute(l)}const m=h(),r=t._asyncData[s.value];r._deps++;const D=n.server!==!1&&t.payload.serverRendered;{let l=function(c){const i=t._asyncData[c];i?._deps&&(i._deps--,i._deps===0&&i?._off())};const d=Z();if(d&&D&&n.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const c=d._nuxtOnBeforeMountCbs;U(()=>{c.forEach(i=>{i()}),c.splice(0,c.length)}),Y(()=>c.splice(0,c.length))}const C=d&&(d._nuxtClientOnly||X($,!1));D&&t.isHydrating&&(r.error.value||r.data.value!==void 0)?r.status.value=r.error.value?"error":"success":d&&(!C&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?d._nuxtOnBeforeMountCbs.push(m):n.immediate&&r.status.value!=="success"&&m();const f=x(),_=p(s,(c,i)=>{if((c||i)&&c!==i){v=!0;const O=t._asyncData[i]?.data.value!==void 0,T=t._asyncDataPromises[i]!==void 0,S={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[c]?._init){let P;i&&O?P=t._asyncData[i].data.value:(P=n.getCachedData(c,t,{cause:"initial"}),S.cachedData=P),t._asyncData[c]=N(t,c,o,n,P)}t._asyncData[c]._deps++,i&&l(i),(n.immediate||O||T)&&t._asyncData[c].execute(S),R(()=>{v=!1})}},{flush:"sync"}),b=n.watch?p(n.watch,()=>{v||(t._asyncData[s.value]?._execute.isPending()&&R(()=>{t._asyncData[s.value]?._execute.flush()}),t._asyncData[s.value]?._execute({cause:"watch",dedupe:n.dedupe}))}):()=>{};f&&j(()=>{_(),b(),l(s.value)})}const y={data:E(()=>t._asyncData[s.value]?.data),pending:E(()=>t._asyncData[s.value]?.pending),status:E(()=>t._asyncData[s.value]?.status),error:E(()=>t._asyncData[s.value]?.error),refresh:(...l)=>t._asyncData[s.value]?._init?t._asyncData[s.value].execute(...l):h()(),execute:(...l)=>y.refresh(...l),clear:()=>{const l=t._asyncData[s.value];if(l?._abortController)try{l._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{l._abortController=void 0}H(t,s.value)}},g=Promise.resolve(t._asyncDataPromises[s.value]).then(()=>y);return Object.assign(g,y),g}function E(a){return w({get(){return a()?.value},set(e){const u=a();u&&(u.value=e)}})}function A(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}async function na(a){await new Promise(u=>q(u)),await B().hooks.callHookParallel("app:data:refresh",void 0)}function H(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=F(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function K(a,e){const u={};for(const o of e)u[o]=a[o];return u}function N(a,e,u,o,n){a.payload._errors[e]??=void 0;const v=o.getCachedData!==L,s=u,t=o.deep?z:M,h=n!==void 0,m=a.hook("app:data:refresh",async D=>{(!D||D.includes(e))&&await r.execute({cause:"refresh:hook"})}),r={data:t(h?n:o.default()),pending:w(()=>r.status.value==="pending"),error:G(a.payload._errors,e),status:M("idle"),execute:(...D)=>{const[y,g=void 0]=D,l=y&&g===void 0&&typeof y=="object"?y:{};if(a._asyncDataPromises[e]&&(l.dedupe??o.dedupe)==="defer")return a._asyncDataPromises[e];{const f="cachedData"in l?l.cachedData:o.getCachedData(e,a,{cause:l.cause??"refresh:manual"});if(f!==void 0)return a.payload.data[e]=r.data.value=f,r.error.value=void 0,r.status.value="success",Promise.resolve(f)}r._abortController&&r._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),r._abortController=new AbortController,r.status.value="pending";const d=new AbortController,C=new Promise((f,_)=>{try{const b=l.timeout??o.timeout,c=aa([r._abortController?.signal,l?.signal],d.signal,b);if(c.aborted){const i=c.reason;_(i instanceof Error?i:new DOMException(String(i??"Aborted"),"AbortError"));return}return c.addEventListener("abort",()=>{const i=c.reason;_(i instanceof Error?i:new DOMException(String(i??"Aborted"),"AbortError"))},{once:!0,signal:d.signal}),Promise.resolve(s(a,{signal:c})).then(f,_)}catch(b){_(b)}}).then(async f=>{let _=f;o.transform&&(_=await o.transform(f)),o.pick&&(_=K(_,o.pick)),a.payload.data[e]=_,r.data.value=_,r.error.value=void 0,r.status.value="success"}).catch(f=>{if(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==C||r._abortController?.signal.aborted)return a._asyncDataPromises[e];if(typeof DOMException<"u"&&f instanceof DOMException&&f.name==="AbortError")return r.status.value="idle",a._asyncDataPromises[e];r.error.value=Q(f),r.data.value=F(o.default()),r.status.value="error"}).finally(()=>{d.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=C,a._asyncDataPromises[e]},_execute:V((...D)=>r.execute(...D),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{m(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),v||I(()=>{a._asyncData[e]?._init||(H(a,e),r.execute=()=>Promise.resolve())})}};return r}const k=()=>{},L=(a,e,u)=>{if(e.isHydrating)return e.payload.data[a];if(u.cause!=="refresh:manual"&&u.cause!=="refresh:hook")return e.static.data[a]};function aa(a,e,u){const o=a.filter(s=>!!s);if(typeof u=="number"&&u>=0){const s=AbortSignal.timeout?.(u);s&&o.push(s)}if(AbortSignal.any)return AbortSignal.any(o);const n=new AbortController;for(const s of o)if(s.aborted){const t=s.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}return n.signal}const v=()=>{const t=o.find(h=>h.aborted)?.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}};for(const s of o)s.addEventListener?.("abort",v,{once:!0,signal:e});return n.signal}export{na as r,sa as u};
